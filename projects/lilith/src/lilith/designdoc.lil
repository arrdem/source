!defscope[designdoc]
!scope[designdoc]

!def[pitch]
!frag[lang: md]

# The Lilith Pitch

Code is more than .. just code for the compiler.
We write lots of artifacts related to our software
 - Design document
 - Formatted API listing
 - Formatted book which is MORE than just the API / source listing
 - A spec? OpenAPI example
 - Doctests? / inline test cases

Theory - most of your "program" isn't code.
idea: the parser is going to IGNORE stuff by default.

Let's build an M-expression syntax with support for multiple co-equal languages and fragments/scopes with a meta-syntax allowing for references between them and consuming fragment-notation-defined blocks? (FIXME: better word?)

!def[sytnax]
!frag[lang: md]

\![] bang-brackets is a meta-syntactic directive used both by the lil tangler and the lil object language.

Programs consist of many fragments, which can reference each-other and from which executable framents are woven.

Fragments define interpretations and scopes.

Interpretations control sub-languages, the bang-bracket notation is more of a meta-language than a target language.
Interpretation is defined by the `lang:` key of a bang-bracket.

FIXME: how to define more langs?

FIXME: how do scopes get defined?
\!defscope[name: <>]

FIXME: we need bare words, we need strings

FIXME: We need the object language

!def[main]
!frag[lang: lil]
; is importing a bang-operation?
import[tagle]
print[tangle[pitch, syntax]]
